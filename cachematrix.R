## makeCacheMatrix and cacheSolve functions are collaboratively 
## implementing a caching functionality on calculating the inverse of a 
## given invertible matrix and storing the results in a cached memory 
## for recurring references. They should be called in sequence:
##   First makeCacheMatrix is to be called. The input parameter is the 
##   derired invertible matrix for which the inversed matrix is to be calculated
##
##   Second cacheSolve is to be called. The input parameter is the 
##   output of makeCacheMatrix which is a list of functions to be called by cacheSolve
##   The result of cacheSolve is the inverse of the input matrix
##   
##   The subseuqent calls of cacheSolve would fetch the inverse of the input
##   matrix from cache and does not involve calculating it. However for any
##   new input matrix, function makeCacheMatrix needs to be called again
##   followed by cacheSolve.

##   makeCacheMatrix encapsulates caching functionality for a matrix.
##   It allocates global memory for a given matrix as input and another
##     matrix as the result of some operation - e.g. solve
##     and provides functions to initialize and fetch each of the two matrices
##   
##   1) Defines a null matrix (inv) as and allocates memory for it
##   2) Defines four functions: set, get, setinv and getinv
##     3.1) set function 
##          initializes the original matrix in cache
##          initializes the resulting matrix as an empty in cache
##     3.2) get function returns the original matrix stored in cache
##     3.3) setinv function stores the resulting matrix in cache
##     3.4) getinv function returns the resulting matrix stored in cache
makeCacheMatrix <- function(m = matrix()) {
  inv = matrix()
  set <- function(y) {
    m <<- y
    inv <<- matrix()
  }
  get <- function() m
  setinv <- function(i) inv <<- i
  getinv <- function() inv
  list(set = set, get = get,
       setinv = setinv,
       getinv = getinv)
}


##   cacheSolve does the matrix functionality of inverse (solve) for a matrix.
##   But before doing the calculation it checks if the input matrix is
##   a new matrix or an old one. It new, it has to run the calculation
##   otherwise it fetches the already stored results from cache.

##   The input parameter of cacheSolve is not the input matrix directly.
##   The input parameter is the list of functions generated by the previous call
##   of makeCacheMatrix. Through calling the functions embedded in the 
##   input parameter, cahceSolve gets access to both the input matrix and the cached
##   resulting matrix. Therefore it can decide whether to calculate the inverse
##   or fetch it from cahche. 
##   If calculation is necessarry, cacheSolve calls "get" to first
##   fetch the original matrix and after calculating the inverse, calls "setinv" 
##   function to store the new results in cache. 

cacheSolve <- function(x, ...) {
  ## Return a matrix that is the inverse of 'x'
  invrs <- x$getinv()
  if(all(!is.na(invrs))) {
    message("getting cached data")
    return(invrs)
  }
  data <- x$get()
  invrs <- solve(data, ...)
  x$setinv(invrs)
  invrs
}

## Here are two examples of calculating the inverse of two matrices
##First matrix
m <- matrix(c(1, -1, 1, 2), 2,2)
x <- makeCacheMatrix(m)
inv <- cacheSolve(x)
inv
z = cacheSolve(x) # Gets from Cahce
z
##Second matrix
n <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(n)
inv <- cacheSolve(x)
inv
z = cacheSolve(x) # Gets from Cahce
z
